// Generated by CoffeeScript 1.6.3
module.exports = function(options) {
  var async, exec, fs, mime, mktemp, music, path, _;
  if (options == null) {
    options = {};
  }
  _ = require('underscore');
  fs = require('fs');
  path = require('path');
  mime = require('mime');
  music = require('musicmetadata');
  async = require('async');
  mktemp = require('mktemp');
  exec = require('child_process').exec;
  options.ext || (options.ext = 'thumbnail');
  options.path || (options.path = path.resolve());
  options.cache || (options.cache = '/tmp');
  options.timeout || (options.timeout = 5000);
  return function(req, res, next) {
    var $stat, dst, img, regex, src, tag, type;
    regex = new RegExp("\." + options.ext + "$");
    if (regex.test(req._parsedUrl.pathname)) {
      req.connection.setTimeout(options.timeout);
      src = path.join(options.path, decodeURI(req._parsedUrl.pathname.replace(regex, '')));
      $stat = function(src) {
        return _.extend(fs.statSync(src), {
          path: src,
          name: path.basename(src)
        });
      };
      if (!fs.existsSync(src)) {
        return next();
      }
      src = (function(src) {
        var data, file, _i, _len, _ref;
        if (typeof src === 'string') {
          src = $stat(src);
        }
        if (!src.isDirectory()) {
          return [src];
        }
        data = [];
        _ref = fs.readdirSync(src.path);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          data.push(file = $stat(path.join(src.path, file)));
          if (file.isDirectory()) {
            data = data.concat(arguments.callee(file));
          }
        }
        return data;
      })(src);
      if (src.length === 0) {
        return next();
      }
      src = _.reject(src, function(src) {
        return src.isDirectory();
      });
      src = (_.sortBy(src, function(src) {
        return src.mtime;
      }))[0];
      tag = "" + src.dev + "-" + src.ino + "-" + (src.mtime.getTime());
      if (req.headers['if-none-match'] === ("\"" + tag + "\"")) {
        res.statusCode = 304;
        return res.end();
      }
      dst = path.join(options.cache, "" + tag + ".jpg");
      img = new Buffer(fs.existsSync(dst) ? fs.readFileSync(dst) : 0);
      if (0 < img.length) {
        res.statusCode = 200;
        res.setHeader('ETag', "\"" + tag + "\"");
        res.setHeader('Cache-Control', 'public');
        res.setHeader('Content-Type', mime.lookup('jpg'));
        res.setHeader('Content-Length', img.length);
        return res.end(img);
      }
      type = mime.lookup(src.name);
      return async.series([
        function(done) {
          var tmpjpg, tmppdf;
          if (/^image/.test(type)) {
            img = new Buffer(fs.readFileSync(src.path));
            return done(null);
          }
          if (/^audio/.test(type)) {
            return (new music(fs.createReadStream(src.path))).on('metadata', function(id3) {
              if (!id3.picture[0]) {
                return done(new Error('no thumbnail'));
              }
              img = id3.picture[0].data;
              return done(null);
            });
          }
          if (/^video/.test(type)) {
            return exec("ffmpeg -i '" + (src.path.replace(/'/g, "'\\''")) + "'", function(err, stdout, stderr) {
              var time, tmpjpg;
              time = (stderr.replace(/^[\s\S]*Duration: (.*?),[\s\S]*$/, '$1')).split(':');
              time = (parseInt(time[0])) * 60 * 60 + (parseInt(time[1])) * 60 + (parseFloat(time[2]));
              tmpjpg = mktemp.createFileSync(path.join(options.cache, 'XXXXXX.jpg'));
              console.log(parseInt(time / 3));
              return exec("ffmpeg -y -ss " + (parseInt(time / 3)) + " -vframes 1 -i '" + src.path + "' -f image2 '" + tmpjpg + "'", function(err) {
                img = new Buffer(fs.readFileSync(tmpjpg));
                if (fs.existsSync(tmpjpg)) {
                  fs.unlinkSync(tmpjpg);
                }
                return done(null);
              });
            });
          }
          if (/pdf$/.test(type)) {
            tmppdf = mktemp.createFileSync(path.join(options.cache, 'XXXXXX.pdf'));
            tmpjpg = mktemp.createFileSync(path.join(options.cache, 'XXXXXX.jpg'));
            return exec("pdftk '" + src.path + "' cat 1 output '" + tmppdf + "' && convert -define jpeg:density=24 -density 24 '" + tmppdf + "[0]' '" + tmpjpg + "'", function(err) {
              img = new Buffer(fs.readFileSync(tmpjpg));
              if (fs.existsSync(tmppdf)) {
                fs.unlinkSync(tmppdf);
              }
              if (fs.existsSync(tmpjpg)) {
                fs.unlinkSync(tmpjpg);
              }
              return done(err);
            });
          }
          return done(new Error('no thumbnail'));
        }, function(done) {
          var tmp;
          tmp = mktemp.createFileSync(path.join(options.cache, 'XXXXXX.jpg'));
          fs.writeFileSync(tmp, img);
          return exec("convert -define jpeg:size=160x160 -resize 160x160 '" + tmp + "' '" + dst + "'", function(err) {
            img = new Buffer(fs.readFileSync(dst));
            if (fs.existsSync(tmp)) {
              fs.unlinkSync(tmp);
            }
            return done(err);
          });
        }
      ], function(err) {
        if (err) {
          console.error(err, src.path);
          return next();
        }
        res.statusCode = 200;
        res.setHeader('ETag', "\"" + tag + "\"");
        res.setHeader('Cache-Control', 'public');
        res.setHeader('Content-Type', mime.lookup('jpg'));
        res.setHeader('Content-Length', img.length);
        return res.end(img);
      });
    } else {
      return next();
    }
  };
};
